<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta property="wb:webmaster" content="7e72a191affb5721" />
    <meta name="description" content="Redux浅论">
    <meta name="keywords" content="Redux,Qian,Lun,Redux Qian Lun,Redux浅论">
    <!-- <meta http-equiv="Expires" content="0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="Cache" content="no-cache"> -->
    <title>Redux浅论</title>
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="../static/css/base.css">
    <link rel="stylesheet" href="../static/css/mark.css">
    <link rel="stylesheet" href="../static/font/iconfont.css">
    <!--[if lt IE 9]>
    <script src="../static/js/html5.js"></script>
    <![endif]-->
    <script type="application/javascript" src="../static/js/jquery.min.js"></script>
</head>

<body class="body__note">
    <header class="header">
        <div class="header__content w-900">
            <h1 class="content__title">
                <a class="title__link-a" href="https://github.com/kangcafe" target="_blank">kang`s cafe<span class="title__link-span--icon iconfont icon-github"></span></a>
            </h1>
            <small class="content__btn">
                <a class="content__btn-a" href="./note.html">BACK HOME</a>
            </small>
        </div>
    </header>


<div class="container w-900">
    <h1><span class="header-link" id="redux">redux</span></h1><!-- toc -->
<section class="content__section"><div class="content-box__markdown--toc"><ol>
<li><a href="#redux特性">Redux特性</a><ol>
<li><a href="#redux原则">Redux原则</a></li>
<li><a href="#单向数据流">单向数据流</a></li>
</ol>
</li>
<li><a href="#store">Store</a><ol>
<li><a href="#dispatch">Dispatch</a></li>
<li><a href="#subscribe">Subscribe</a></li>
<li><a href="#getstate">GetState</a></li>
<li><a href="#replacereducer">ReplaceReducer</a></li>
<li><a href="#state">State</a><ol>
<li><a href="#state扁平化">State扁平化</a></li>
<li><a href="#可变对象">可变对象</a></li>
<li><a href="#不可变对象">不可变对象</a></li>
<li><a href="#reselect">Reselect</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#action">Action</a><ol>
<li><a href="#action-creator">Action Creator</a><ol>
<li><a href="#同步action-creator">同步Action Creator</a></li>
<li><a href="#异步action-creator">异步Action Creator</a></li>
</ol>
</li>
<li><a href="#bindactioncreators">bindActionCreators</a></li>
</ol>
</li>
<li><a href="#reducer">Reducer</a><ol>
<li><a href="#combinereducers">combineReducers</a></li>
</ol>
</li>
<li><a href="#react-redux">React-redux</a><ol>
<li><a href="#provider">Provider</a></li>
<li><a href="#connect">Connect</a></li>
</ol>
</li>
</ol>
</div></section>

<!-- toc stop -->
<p><img src="../static/img/redux/logo_1.png" alt="ReduxLogo"></p>
<blockquote>
<p>Redux is a predictable state container for JavaScript apps<sup id="footnoteUp_1" data-desc="redux_website_title_desc" class="reference"><a class="footnoteUp" href="#footnoteDo_1">[1]</a></sup>.</p>
</blockquote>
<h2><span class="header-link" id="redux特性">Redux特性</span></h2><p>在过去的十几年里<a href="https://en.wikipedia.org/wiki/Web_page">web page</a>一直都以指数递增的方式发展，无论是概念上还是编程上想要彻底读懂这门设计的艺术已经变得不可为，如今在许多大型网站中的一个页面从<code>DOM</code>与<code>Event</code>的微观角度往往聚集着一系列复杂并琐碎的行为功能<sup id="footnoteUp_2" data-desc="behavioral_functionality_desc" class="reference"><a class="footnoteUp" href="#footnoteDo_2">[2]</a></sup>，它们聚合在一起构成了我们今天可以在浏览器端可操作的视图，正是如此，怎样管理这些行为功能被提上日程，诸多才华横溢的工程师们引申出状态管理的概念，制作出许多优秀的作品，如<a href="https://github.com/reactjs/redux">Redux</a>、<a href="https://github.com/facebook/flux">flux</a>、<a href="https://github.com/acdlite/flummox">flummox</a>、<a href="https://github.com/mobxjs/mobx">mobxjs</a>、<a href="https://github.com/reflux/refluxjs">refluxjs</a>、<a href="https://github.com/martyjs/marty">martyjs</a>、<a href="https://github.com/jakesgordon/javascript-state-machine">javascript-state-machine</a>、<a href="https://github.com/vuejs/vuex">vuex</a>等，其中又以<code>redux</code>和<code>flux</code>最为流行。</p>
<p><img src="../static/img/redux/action-store-view.png" alt="svg"></p>
<p>Redux作为一个<a href="https://en.wikipedia.org/wiki/JavaScript">javascript</a>应用的可预测状态（state）容器，借鉴flux的数据单向流动、<a href="http://elm-lang.org/">elm</a>的<a href="http://guide.elm-lang.org/architecture/">The Elm Architecture</a>、<a href="https://github.com/timoxley/functional-javascript-workshop">函数式编程</a>、<a href="https://en.wikipedia.org/wiki/Currying">柯里化（Currying）</a>函数、<a href="https://en.wikipedia.org/wiki/Composite_pattern">组合模式（Composite pattern）</a>的等思想。将视图（view）中可操作的这些行为类比为动作（action），对应为状态（state），状态引导动作进行视图更新，redux状态容器<a href="http://redux.js.org/docs/basics/Store.html">store</a>对状态（state）进行同一管理，可以说store可预测状态容器是redux的骨架也不为过。</p>
<h3><span class="header-link" id="redux原则">Redux原则</span></h3><p>Redux在文档中规定了三条原则（<a href="http://redux.js.org/docs/introduction/ThreePrinciples.html">Three Principles</a>）：“Single source of truth”、“State is read-only”和“Changes are made with pure functions”，用于描述在redux整个生命周期内怎样去管理和维护store树。</p>
<ul>
<li>单一数据源：State被存储在一颗唯一的<code>object tree</code>上，即store。</li>
<li>State只读：State树内所有<code>key-&gt;value</code>只读，惟一改变state的方法就是触发action。</li>
<li>Reducer函数：State树内的state只能依靠纯函数reducer对它进行更新。</li>
</ul>
<h3><span class="header-link" id="单向数据流">单向数据流</span></h3><p>单向数据流（Unidirectional data flow），即从模型到视图的数据流动，它区别于<code>双向数据绑定</code>的方式，用react中的术语解释的话就是，当某个组件的数据<code>prop</code>需要变化并且通过相关方法操作更新state之后，store会从父节点传递到子节点，依次向下遍历整棵组件树，以组件为单位寻找使用了变化的<code>prop</code>的组件进行渲染。假定一个react渲染的页面，组件包含关系为<code>A ⊇ {B, C} &amp;&amp; C ⊇ D</code>，其中<code>B</code>和<code>C</code>子组件都引用了store树上的<code>props.test</code>属性，这是一个非常典型的从上到下单向流动的阶梯式模型。</p>
<p><img src="../static/img/redux/redux-stroe-up-down.png" alt="svg"></p>
<p>当在<code>B</code>组件内某个操作（UI交互、API调用等）更新了state值（即<code>props.test</code>属性值），这个操作本身并不会对<code>B</code>组件进行干扰和操作，<code>B</code>组件和<code>D</code>组件会在store树内的相应state值变化后触发组件使view发生改变。</p>
<p><img src="../static/img/redux/redux-stroe-up-down_2.png" alt="svg"></p>
<p>紫色线条是数据流向，紫色方框是触发渲染的子组件，数据从顶层store开始向下流淌，store顶层数据发生改变后会分别触发存在<code>props.test</code>属性的子组件进行重新渲染更新<code>DOM</code>，以达到视图渲染可控、状态重现可控的目的。</p>
<!--
### 反向数据流
### 同步数据流
### 异步数据流
-->
<h2><span class="header-link" id="store">Store</span></h2><p>Store是一个由<code>createStore(reducer, preloadedState, enhancer)</code>方法创建的javascript对象，用于存储状态树。</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> {createStore} <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> makeRootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducers'</span>;
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (initialState = {}, history) =&gt; {
  <span class="hljs-keyword">const</span> store         = createStore(
    makeRootReducer(),
    initialState,
  );

  <span class="hljs-keyword">return</span> store
}
</code></pre>
<p>阅读redux源码的createStore函数可以看到最后返回四个核心对象和一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">symbol</a>对象。</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> $$observable <span class="hljs-keyword">from</span> <span class="hljs-string">'symbol'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStore</span>(<span class="hljs-params">reducer, preloadedState, enhancer</span>) </span>{
  ...
  return {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable
  }
}
</code></pre>
<table>
<thead>
<tr>
<th>方法</th>
<th>定义</th>
<th>使用方式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>dispatch</td>
<td>执行接口</td>
<td>store.dispatch(action)</td>
<td>接受action参数进行store更新，并分发给subscribe过的reducer，执行回调函数</td>
</tr>
<tr>
<td>subscribe</td>
<td>订阅接口</td>
<td>store.subscribe(cb)</td>
<td>在每次执行dispatch的时候，用于执行自定义的回调函数操作</td>
</tr>
<tr>
<td>getState</td>
<td>数据接口</td>
<td>store.getState()</td>
<td>redux对外导出数据</td>
</tr>
<tr>
<td>replaceReducer</td>
<td>重置store接口</td>
<td>store.replaceReducer(nextReducer)</td>
<td>重置redux的reducer，重新启动store流程</td>
</tr>
</tbody>
</table>
<h3><span class="header-link" id="dispatch">Dispatch</span></h3><p>Dispatch方法用于更新store状态树，流程是在dispatch接受一个action，由action决定调用reducer转换状态树， 且通知监听者数据已发生变化，从dispatch源码中看到函数<code>currentReducer(currentState, action)</code>传递state、action，观察者列表<code>listeners</code>直接for循环遍历执行<code>listeners[i]()</code>。</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(action)</span> {</span>
   ...
     currentState = currentReducer(currentState, action)
   ...

   var listeners = currentListeners = nextListeners
   <span class="hljs-keyword">for</span> (var <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; listeners.<span class="hljs-built_in">length</span>; <span class="hljs-built_in">i</span>++) {
     listeners[i]()
   }

   <span class="hljs-keyword">return</span> action
 }
</code></pre>
<p>这里以<code>dispatch(action)</code>方式图示dispatch函数的执行过程。</p>
<p><img src="../static/img/redux/dispatch-desc.png" alt="svg"></p>
<pre><code class="lang-js">const <span class="hljs-built_in">action</span> = { <span class="hljs-built_in">type</span>: <span class="hljs-string">'ADD'</span>, payload: <span class="hljs-string">'***'</span>};
dispatch(<span class="hljs-built_in">action</span>);
</code></pre>
<p>另外还有<code>bindActionCreators(action)</code>函数方式。</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> action = { <span class="hljs-keyword">type</span>: <span class="hljs-string">'ADD'</span>, payload: <span class="hljs-string">'***'</span>};
<span class="hljs-keyword">const</span> bindActionCreators = <span class="hljs-built_in">require</span>(<span class="hljs-string">'redux'</span>).bindActionCreators;
bindActionCreators(action);
</code></pre>
<p><code>dispatch action creator</code>函数方式</p>
<pre><code class="lang-js"><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">addTodo</span>(text) {
  <span class="hljs-selector-tag">return</span> {
    <span class="hljs-attribute">type</span>: ADD,
    <span class="hljs-attribute">payload</span>: text,
  }
}
store<span class="hljs-selector-class">.dispatch</span>(addTodo(<span class="hljs-string">'***'</span>));
</code></pre>
<p>每次执行dispatch，通过subscribe注册的listener都会被执行，当listener列表较多时<code>listeners[i]()</code>都会被执行由此产生性能损耗，从工程师的角度更难定位到哪个具体的reducer内的监听者被触发，这个时候需要一些辅助工具借助<code>applyMiddleware</code>函数扩展中间件来帮助开发者。</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> {applyMiddleware} <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-thunk'</span>;
<span class="hljs-keyword">const</span> store = applyMiddleware([thunk])(createStore);
<span class="hljs-keyword">const</span> dispatch = store.dispatch;
</code></pre>
<blockquote>
<p>Middleware is the suggested way to extend Redux with custom functionality<sup id="footnoteUp_3" data-desc="redux_middleware_wedsite_desc" class="reference"><a class="footnoteUp" href="#footnoteDo_3">[3]</a></sup>.</p>
</blockquote>
<p>更全面具体一些的扩展就要说到redux中间件的概念，如果熟悉expressjs<sup id="footnoteUp_4" data-desc="redux_expressjs_middleware_list_desc" class="reference"><a class="footnoteUp" href="#footnoteDo_4">[4]</a></sup>或者koajs<sup id="footnoteUp_5" data-desc="redux_koa_middleware_list_desc" class="reference"><a class="footnoteUp" href="#footnoteDo_5">[5]</a></sup>，应该会对<a href="https://github.com/alsotang/node-lessons/tree/master/lesson18">Middleware</a>很熟悉，在redux中的中间件是一个高阶函数，通俗讲更多的是对现有dispatch函数进行扩展，其逻辑倾向于AOP<sup id="footnoteUp_6" data-desc="aspect_oriented_programming_desc" class="reference"><a class="footnoteUp" href="#footnoteDo_6">[6]</a></sup>，意在将散布在各处的横切代码（cross-cutting code）以及一些被重复使用的功能性组件被重复使用。</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> {applyMiddleware, compose, createStore} <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> {routerMiddleware} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-redux'</span>;
<span class="hljs-keyword">import</span> thunkMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-thunk'</span>;
<span class="hljs-keyword">import</span> {persistState} <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-devtools'</span>;
<span class="hljs-keyword">import</span> makeRootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducers'</span>;
<span class="hljs-keyword">import</span> DevTools <span class="hljs-keyword">from</span> <span class="hljs-string">'../containers/DevTools'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (initialState = {}, history) =&gt; {
  ...
  <span class="hljs-keyword">const</span> middleware = [thunkMiddleware, routerMiddleware(history), ...debugware];
  <span class="hljs-keyword">const</span> enhancers = [];
  ...
      enhancers.push(devToolsExtension())
  ...
  <span class="hljs-keyword">const</span> store         = createStore(
    makeRootReducer(),
    initialState,
    compose(
      applyMiddleware(...middleware),
      ...enhancers
    )
  );
  ...
      store.replaceReducer(reducers(store.asyncReducers))
  ...
  <span class="hljs-keyword">return</span> store
}
</code></pre>
<p><img src="../static/img/redux/redux-middleware.png" alt="svg"></p>
<p>制作中间件一般用到dispatch和getState两个方法。</p>
<h3><span class="header-link" id="subscribe">Subscribe</span></h3><h3><span class="header-link" id="getstate">GetState</span></h3><h3><span class="header-link" id="replacereducer">ReplaceReducer</span></h3><h3><span class="header-link" id="state">State</span></h3><p>State对象存储在store状态树中，state只能通过<code>dispatch(action)</code>来触发更新，更新逻辑由reducer来执行，需要注意的是当state变化时会返回全新的对象，而不是修改传入的参数。</p>
<p><img src="../static/img/redux/store-state-view.png" alt="svg"></p>
<p>这里示例的逻辑由四步分组成，第一部分是定义子路由，在子路由中引入用于收集reducer的回调函数，我命名为injectReducer，当然也可以命名其它的名字，如collectReducer、pushReducer等等都可以</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { injectReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../store/reducers'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (store) =&gt; ({
  path: <span class="hljs-string">'login'</span>,
  getComponent (nextState, cb) {
    <span class="hljs-built_in">require</span>.ensure([], (<span class="hljs-built_in">require</span>) =&gt; {
      <span class="hljs-keyword">const</span> LoginPage = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./components/Login'</span>).<span class="hljs-keyword">default</span>;
      <span class="hljs-keyword">const</span> reducer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./extend/reducer'</span>).<span class="hljs-keyword">default</span>;
      injectReducer(store, { key: <span class="hljs-string">'login_reducer'</span>, reducer });
      cb(<span class="hljs-literal">null</span>, LoginPage);
    }, <span class="hljs-string">'login'</span>)
  }
})
</code></pre>
<p>在第一部分中store和reducer已经被传入injectReducer中，第二部分就是injectReducer函数的内部逻辑。</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { combineReducers } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>
<span class="hljs-keyword">import</span> { routerReducer as router } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-redux'</span>

<span class="hljs-keyword">export</span> const makeRootReducer = <span class="hljs-function"><span class="hljs-params">(asyncReducers)</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> combineReducers({
    router,
    ...asyncReducers
  })
};

<span class="hljs-keyword">export</span> const injectReducer = <span class="hljs-function"><span class="hljs-params">(store, { key, reducer })</span> =&gt;</span> {
  store.asyncReducers[key] = reducer;
  store.replaceReducer(makeRootReducer(store.asyncReducers))
};

<span class="hljs-keyword">export</span> default makeRootReducer
</code></pre>
<p>InjectReducer函数内用replaceReducer方法将store重新计算，这里这样做的缘由是第一部分的子路由是异步加载的，并不是在服务器开始时直接加载完毕，而是随着用户在客户端不断操作页面异步更新reducer以及加载组件等信息。</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> {applyMiddleware, compose, createStore} from <span class="hljs-string">'redux'</span>;
<span class="hljs-params">...</span>
<span class="hljs-keyword">import</span> makeRootReducer from <span class="hljs-string">'./reducers'</span>;

export default (initialState = {}, history) =&gt; {
  <span class="hljs-params">...</span>
  const store         = createStore(
    makeRootReducer(),
    initialState,
    compose(
      applyMiddleware(<span class="hljs-params">...</span>middleware),
      <span class="hljs-params">...</span>enhancers
    )
  );
  <span class="hljs-params">...</span>
    store.replaceReducer(reducers(store.asyncReducers))
  <span class="hljs-params">...</span>
  <span class="hljs-keyword">return</span> store
}
</code></pre>
<p>第三部分是初始化store。</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> CoreLayout <span class="hljs-keyword">from</span> <span class="hljs-string">'../layouts/CoreLayout/components/CoreLayout'</span>;
<span class="hljs-keyword">import</span> {Dashboard} <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createRoutes = (store) =&gt; ({
  path      : <span class="hljs-string">'/'</span>,
  component : CoreLayout,
  indexRoute: Home,
  getChildRoutes(location, cb) {
    cb(<span class="hljs-literal">null</span>, [
      Dashboard(store)
    ])
  }
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> createRoutes
</code></pre>
<p>第四部分是初始化路由，按道理顺序应该是第四部分=&gt;第三部分=&gt;第一部分=&gt;第二部分，但是如果考虑异步等信息的话，我个人认为按逻辑优先级应该是这样排比较好。</p>
<h4><span class="header-link" id="state扁平化">State扁平化</span></h4><p>在redux开发过程中，为避免不同数据之间相互引用或返回相互嵌套的值，可以使用<a href="https://github.com/paularmstrong/normalizr">normalizr</a>对state扁平化、范式化处理。</p>
<pre><code class="lang-bash">npm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save normalizr</span>
</code></pre>
<p>store树对象或者组件自身state树对象实质上是<a href="https://en.wikipedia.org/wiki/JSON">JSON</a>对象</p>
<h5><span class="header-link" id="可变对象">可变对象</span></h5><p>lodash 的 cloneDeep
但是复杂数据的深度拷贝损耗性能，这个时候就需要引用不可变对象解决问题。</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> <span class="hljs-built_in">assign</span> = Object.<span class="hljs-built_in">assign</span> || require(<span class="hljs-string">'object.assign'</span>)<span class="hljs-comment">;</span>
<span class="hljs-built_in">assign</span>({}, state, {
    ADD: action.newState
  })
</code></pre>
<h5><span class="header-link" id="不可变对象">不可变对象</span></h5><p><a href="https://en.wikipedia.org/wiki/Immutable_object">不可变对象（immutable state）</a>是指在创建后不可再被修改的对象，它可以通过引用级的比对检查来提升渲染性能，在redux开发中一般会使用<a href="https://facebook.github.io/immutable-js/">immutablejs</a>实现不可变对象，需要注意的是immutablejs每次操作之后总是返回一个新的数据，原有的数据不会改变。</p>
<p>immutablejs通过结构共享来解决的数据拷贝时的性能问题，即当数据对象<code>key-&gt;value</code>键值对被改变时，immutablejs会只<code>clone</code>数据对象被改变对象节点的父节点以上的部分，其他保持不变，由此达到旧对象与immutablejs返回的新对象共享部分数据并提高性能。</p>
<p><img src="../static/img/redux/immutablejs-node-expample.png" alt="svg">
测试：</p>
<ul>
<li><a href="https://www.npmjs.com/package/deep-freeze-node">deep-freeze-node</a></li>
</ul>
<h4><span class="header-link" id="reselect">Reselect</span></h4><p><a href="https://github.com/reactjs/reselect">reselect</a></p>
<p>带 cache 功能的 selector，使用Resselect避免不必要的selector计算</p>
<h2><span class="header-link" id="action">Action</span></h2><p>Action同样是一个javascript对象，通常包含<code>type</code>等一些字段。</p>
<h3><span class="header-link" id="action-creator">Action Creator</span></h3><p>“Action Creator”是action的创造者，本质上就是一个函数，返回值是一个action，“Action Creator”可以是同步也可以是异步。</p>
<h4><span class="header-link" id="同步action-creator">同步Action Creator</span></h4><pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-type">{</span> tyle: <span class="hljs-symbol">'ADD</span>' }
}
dispatch(add());
</code></pre>
<h4><span class="header-link" id="异步action-creator">异步Action Creator</span></h4><p>redux-thunks 和 redux-promise 分别是使用异步回调和 Promise 来解决异步 action 问题的。</p>
<p><a href="https://www.npmjs.com/package/isomorphic-fetch">https://www.npmjs.com/package/isomorphic-fetch</a></p>
<pre><code class="lang-js"><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">fetchDataAsync</span>() {
    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">function</span> (dispatch) {
      <span class="hljs-selector-tag">fetch</span>(<span class="hljs-string">'/posttest'</span>, {
        <span class="hljs-attribute">method </span>: <span class="hljs-string">'POST'</span>,
        <span class="hljs-attribute">headers</span>: {
          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">"application/json"</span>,
          <span class="hljs-string">'Accept'</span>      : <span class="hljs-string">"application/json"</span>
        },
        <span class="hljs-attribute">body   </span>: JSON.stringify({<span class="hljs-attribute">item</span>: <span class="hljs-string">'text'</span>})
      })<span class="hljs-selector-class">.then</span>(res =&gt; {
        <span class="hljs-selector-tag">if</span> (res.ok) {
          <span class="hljs-selector-tag">dispatch</span>({<span class="hljs-attribute">type</span>: LOGIN_REQUEST, <span class="hljs-attribute">loginRequest</span>: true});
          ...
        }
      }, e =&gt; {
        ...
      });
    }
}
</code></pre>
<h3><span class="header-link" id="bindactioncreators">bindActionCreators</span></h3><p><code>bindActionCreators()</code>可以自动把多个action创建函数绑定到<code>dispatch()</code>方法上。</p>
<p>借鉴store对reducer的封装（减少传入 state 参数）。可以对dispatch进行再一层封装，将多参数转化为单参数的形式，经 bindActionCreators包装过后的“Action Creator”形成了具有改变全局state数据的多个函数，将这些函数分发到各个地方，即能通过调用这些函数来改变全局的state。</p>
<pre><code class="lang-js">var actionCreators = <span class="hljs-keyword">bindActionCreators </span>( actionCreators , store.<span class="hljs-keyword">dispatch </span>) <span class="hljs-comment">;</span>
</code></pre>
<h2><span class="header-link" id="reducer">Reducer</span></h2><p>Reducer是一个javaScript函数，命名上也与<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">Array.prototype.reduce()</a>相像，函数签名为<code>(previousState, action) =&gt; newState</code>，接受previousState和action两个参数，根据<code>action.type</code>中携带的信息对previousState做出相应的处理，并返回一个新的state。另外在redux中一个action可以触发多个reducer，一个reducer中也可以包含多种“action.type”的处理，所以二者关系为多对多。。</p>
<pre><code class="lang-js">import {SET_AUTH} <span class="hljs-keyword">from</span> './actionType';
const assign = Object.assign || require('object.assign');

const initialState = {
  loggedIn    : require('./action').<span class="hljs-keyword">default</span>()(),
};

const ACTION_HANDLERS = {
  [SET_AUTH]     : (<span class="hljs-keyword">state</span>, action) =&gt; assign({}, <span class="hljs-keyword">state</span>, {
    loggedIn: action.newState
  })
};

export <span class="hljs-keyword">default</span> function (<span class="hljs-keyword">state</span> = initialState, action) {
  const handler = ACTION_HANDLERS[action.type];

  return handler ? handler(<span class="hljs-keyword">state</span>, action) : <span class="hljs-keyword">state</span>
}
</code></pre>
<h3><span class="header-link" id="combinereducers">combineReducers</span></h3><p><code>combineReducers()</code>将调用一系列 reducer，并根据对应的 key 来筛选出 state 中的一部分数据给相应的 reducer，这样也意味着每一个小的 reducer 将只能处理 state 的一部分数据，如：filterReducer 将只能处理及返回 state.filter 的数据，如果需要使用到其他 state 数据，那还是需要为这类 reducer 传入整个 state。</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { combineReducers } from <span class="hljs-string">'redux'</span>
<span class="hljs-params">...</span>
  combineReducers({
    router,
    <span class="hljs-params">...</span>asyncReducers
  })
<span class="hljs-params">...</span>
</code></pre>
<h2><span class="header-link" id="react-redux">React-redux</span></h2><p>React通过Context属性，可以将属性props直接给子component，无须通过props层层传递, Provider获得store然后将其传递给子元素。</p>
<pre><code class="lang-js">export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Provider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  getChildContext() {
    <span class="hljs-keyword">return</span> { store: <span class="hljs-keyword">this</span>.store }
  }
  constructor(props, context) {
    <span class="hljs-keyword">super</span>(props, context)
    <span class="hljs-keyword">this</span>.store = props.store
  }
  componentWillReceiveProps(nextProps) {
    const { store } = <span class="hljs-keyword">this</span>
    const { store: nextStore } = nextProps

    <span class="hljs-keyword">if</span> (store !== nextStore) {
      warnAboutReceivingStore()
    }
  }
  render() {
    let { children } = <span class="hljs-keyword">this</span>.props
    <span class="hljs-keyword">return</span> <span class="hljs-type">Children</span>.only(children)
  }
}
<span class="hljs-type">Provider</span>.childContextTypes = {
   store: storeShape.isRequired
}
</code></pre>
<p>Provider中的store可以在子组件中用contextTypes获取。</p>
<pre><code class="lang-js">childrenComponent<span class="hljs-selector-class">.contextTypes</span> = {
    store: storeShape
}
</code></pre>
<p>需要注意的是由于react-redux，我们一般对绑定的组件称为<code>Smart and Dumb Components</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Location</th>
<th style="text-align:left">Use React-Redux</th>
<th style="text-align:left">To read data, they</th>
<th style="text-align:left">To change data, they</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">“Smart” Components</td>
<td style="text-align:left">Top level, route handlers</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Subscribe to Redux state</td>
<td style="text-align:left">Dispatch Redux actions</td>
</tr>
<tr>
<td style="text-align:left">“Dumb” Components</td>
<td style="text-align:left">Middle and leaf components</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Read data from props</td>
<td style="text-align:left">Invoke callbacks from props</td>
</tr>
</tbody>
</table>
<h3><span class="header-link" id="provider">Provider</span></h3><p>Provider将store放到context中，connect就可以获取store，使用store的方法，比如dispatch。其实没有被connect的组件通过声明contextTypes属性也是可以获取store，使用store的方法的，但是这个时候，如果使用dispatch修改了store的state，React-Redux并不能把修改后的state作为props给React组件，可能会导致UI和数据不同步，所以这个时候一定要清楚自己在做什么。</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> React, { Component, PropTypes } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { Router } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router'</span>;
<span class="hljs-keyword">import</span> { Provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">static</span> propTypes = {
    history: PropTypes.object.isRequired,
    routes: PropTypes.object.isRequired,
    store: PropTypes.object.isRequired
  };
  render () {
    <span class="hljs-keyword">const</span> { history, routes, store } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">height:</span> '<span class="hljs-attr">100</span>%' }}&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Router</span> <span class="hljs-attr">history</span>=<span class="hljs-string">{history}</span> <span class="hljs-attr">children</span>=<span class="hljs-string">{routes}</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span>
    )
  }
}
export default AppContainer</span>
</code></pre>
<h3><span class="header-link" id="connect">Connect</span></h3><pre><code class="lang-bash">npm <span class="hljs-selector-tag">i</span> --save react-redux
</code></pre>
<p>Connect是由<a href="https://github.com/reactjs/react-redux">react-redux</a>提供的一个高阶函数。源码中connect函数接收<code>mapStateToProps、mapDispatchToProps、mergeProps、options</code>四个参数返回一个用于生产Component的函数wrapWithConnect，然后再将组件Component作为参数注入<code>wrapWithConnect(WrappedComponent)</code>函数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">mapStateToProps</td>
<td style="text-align:left">在store发生改变的时候才会调用，然后把返回的结果作为组件的props</td>
</tr>
<tr>
<td style="text-align:left">mapDispatchToProps</td>
<td style="text-align:left">主要作用是弱化Redux在React组件中存在感，让在组件内部改变store的操作感觉就像是调用一个通过props传递进来的函数一样。一般会配合Redux的bindActionCreators使用。如果不指定这个函数，dispatch会注入到你的组件props中</td>
</tr>
<tr>
<td style="text-align:left">mergeProps</td>
<td style="text-align:left">用来指定mapStateToProps、mapDispatchToProps、ownProps(组件自身属性)的合并规则，合并的结果作为组件的props。如果要指定这个函数，建议不要太复杂</td>
</tr>
<tr>
<td style="text-align:left">options</td>
<td style="text-align:left">里面主要关注pure，如果你的组件仅依赖props和Redux的state，pure一定要为true，这样能够避免不必要的更新</td>
</tr>
</tbody>
</table>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params">mapStateToProps, mapDispatchToProps, mergeProps, options = {}</span>) </span>{
  ...
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapWithConnect</span>(<span class="hljs-params">WrappedComponent</span>) </span>{
    ...
  }
}
</code></pre>
<table cellspacing="0" cellpadding="0" border="0" class="tableTree"><tbody><tr><td class="treeTd"><br></td><td rowspan="2" class="treeTdNoBorder"><table cellspacing="0" cellpadding="0" border="0"><tbody><tr><td class="treeTd"><br></td><td rowspan="2" class="treeTdNoBorder treeTdContentText">connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {})</td></tr><tr><td class="treeTd2"><br></td></tr><tr><td class="treeTd3"><br></td><td rowspan="2" class="treeTdNoBorder"><table cellspacing="0" cellpadding="0" border="0"><tbody><tr><td class="treeTd"><br></td><td rowspan="2" class="treeTdNoBorder treeTdContentText">wrapWithConnect(WrappedComponent)</td></tr><tr><td class="treeTd2"><br></td></tr><tr><td class="treeTd3"><br></td><td rowspan="2" class="treeTdNoBorder"><table cellspacing="0" cellpadding="0" border="0"><tbody><tr><td class="treeTd"><br></td><td rowspan="2" class="treeTdNoBorder treeTdContentText">class Connect extends Component{}</td></tr><tr><td class="treeTd2"><br></td></tr><tr><td class="treeTd3"><br></td><td rowspan="2" class="treeTdNoBorder"><table cellspacing="0" cellpadding="0" border="0"><tbody><tr><td class="treeTd"><br></td><td rowspan="2" class="treeTdNoBorder treeTdContentText">Connect.contextTypes = {store: storeShape};Connect.propTypes = {store: storeShape}</td></tr><tr><td class="treeTd2"><br></td></tr><tr><td class="treeTd3"><br></td><td rowspan="2" class="treeTdNoBorder"><table cellspacing="0" cellpadding="0" border="0"><tbody><tr><td class="treeTd"><br></td><td rowspan="2" class="treeTdNoBorder treeTdContentText">return hoistStatics(Connect, WrappedComponent)</td></tr><tr><td class="treeTdFooter"><br></td></tr></tbody></table></td></tr><tr><td class="treeTdFooter"><br></td></tr></tbody></table></td></tr><tr><td class="treeTdFooter"><br></td></tr></tbody></table></td></tr><tr><td class="treeTdFooter"><br></td></tr></tbody></table></td></tr><tr><td class="treeTdFooter"><br></td></tr></tbody></table></td></tr><tr><td class="treeTdFooter"><br></td></tr></tbody></table>

<p>值得一说的是hoistStatics函数源于<code>hoist-non-react-statics</code>第三方，作用是将原来组件中的元素拷贝到目标组件。在使用connect函数的时候直接在已声明的component后面引用connect。</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> <span class="hljs-type">React</span>, {<span class="hljs-type">Component</span>} from <span class="hljs-symbol">'reac</span>t';
...
<span class="hljs-keyword">import</span> {connect} from <span class="hljs-symbol">'react</span>-redux';

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Login</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  ...
  render() {
    ...
  }
}
...
export <span class="hljs-keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(<span class="hljs-type">Login</span>)
</code></pre>
<p>Connect不只为react组件提供store中的state数据及扩展dispatch方法，它还为定义的组件添加了一系列事件操作，这些事件的核心点就是store，然后可以在自己定义的组件内获得store。</p>
<pre><code class="lang-js">constructor(){
  //获取store
  this.store = props.store || context.store
  const storeState = this.store.getState()
  //把store的<span class="hljs-keyword">state</span>作为组件的<span class="hljs-keyword">state</span>，后面通过更新<span class="hljs-keyword">state</span>更新组件
  this.<span class="hljs-keyword">state</span> = { storeState }
  //清除组件的状态，内部是一系列的标示还原
  this.clearCache()
}
</code></pre>
<h2><span class="header-link" id="references">References</span></h2><section class="footnote-box"><ul><li id="footnoteDo_1" class="footnoteUp"><span class="backlink" data-desc="redux_website_title_desc"><b><a  href="#footnoteUp_1">^</a></b></span><span class="reference-text"><a href="http://redux.js.org/">redux.js文档</a>，源自<code>redux.js</code>文档中首页的一段话，对<code>redux</code>特性的官方描述。</span></li><li id="footnoteDo_2" class="footnoteUp"><span class="backlink" data-desc="behavioral_functionality_desc"><b><a  href="#footnoteUp_2">^</a></b></span><span class="reference-text">行为功能是对目的功能和有用行为的一种抽象。这里特指在&quot;web&nbsp;page&quot;中对视图的按钮等<code>DOM</code>元素点击、页面路由切换等功能的操作行为，在redux中被称为<a href="http://redux.js.org/docs/basics/Actions.html">action</a>。</span></li><li id="footnoteDo_3" class="footnoteUp"><span class="backlink" data-desc="redux_middleware_wedsite_desc"><b><a  href="#footnoteUp_3">^</a></b></span><span class="reference-text"><a href="http://redux.js.org/docs/api/applyMiddleware.html">applyMiddleware(...middlewares)</a>:Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store&#39;s dispatch method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.</span></li><li id="footnoteDo_4" class="footnoteUp"><span class="backlink" data-desc="redux_expressjs_middleware_list_desc"><b><a  href="#footnoteUp_4">^</a></b></span><span class="reference-text"><a href="http://expressjs.com/">expressjs</a>，中间件的介绍为<a href="http://expressjs.com/en/4x/api.html#express.methods">expressjs-middleware</a>，概括来说中间件<code>middleware</code>函数能够访问请求对象 <code>req</code>、响应对象 <code>res</code> 以及应用程序的请求/响应循环中的下一个中间件<code>middleware</code>函数。下一个中间件函数通常由名为<code>next</code>的变量来表示。</span></li><li id="footnoteDo_5" class="footnoteUp"><span class="backlink" data-desc="redux_koa_middleware_list_desc"><b><a  href="#footnoteUp_5">^</a></b></span><span class="reference-text"><a href="http://koajs.com/">koajs</a>，中间件的介绍为<a href="https://github.com/koajs/koa/wiki">koajs-middleware</a>。</span></li><li id="footnoteDo_6" class="footnoteUp"><span class="backlink" data-desc="aspect_oriented_programming_desc"><b><a  href="#footnoteUp_6">^</a></b></span><span class="reference-text"><a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">AOP（Aspect-Oriented Programming）</a>，面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术，被认为是<a href="https://en.wikipedia.org/wiki/Object-oriented_programming">OOP</a>的一种延续（补充和完善<code>OOP</code>）。</span></li></ul></section>


</div>
<script>
$(function(){
  /**$('pre code').each(function(){
        var lines = $(this).text().split('\n').length - 1;
        var $numbering = $('<ul/>').addClass('pre-numbering');
        $(this)
            .addClass('has-numbering')
            .parent()
            .append($numbering);
        for(i=1;i<=lines;i++){
            $numbering.append($('<li/>').text(i));
        }
    });**/
    $('img').each(function(){
          var _self = $(this);
          var altCache = _self.attr('alt');
          if(altCache === 'svg'){
            var hrefCache = _self.attr('src');
            var dataCache = hrefCache.substr(0,(hrefCache.length-3))+'svg';
            _self.replaceWith('<p class="svgNodePhoto"><object data="'+dataCache+'" type="image/svg+xml"></object></p>')
          }
      });
});
</script>
<footer class="footer w-900">
    <a class="footer__backToTop-btn" href="#" id="back-to-top">
        <i class="footer__backToTop-btn--icon iconfont icon-chevronup"></i>
    </a>
    <a class="footer__github-btn" href="https://github.com/kangcafe" target="_blank">Kang`s Cafe on GitHub</a>
    <div class="ds-thread" data-thread-key="32d7c641-e67d-410b-a659-7d0e414b5c1d" data-title="Redux浅论" data-url="http://kangcafe.com/cn/32d7c641-e67d-410b-a659-7d0e414b5c1d.html"></div>
    <script type="text/javascript">
        var duoshuoQuery = {
            short_name: "kangcafe"
        };
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';
            ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] ||
                document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <section class="content__section">
        <p class="content__a-btn">
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">
                <img alt="Creative Commons License" style="border-width:0" src="../static/bgimg/licensebuttons.png" />
            </a>
        </p>
        <p class="content__p--word">This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"> Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License
        </a>. Reprint the 《<sub>Redux浅论</sub>》 need signature "<sub>kangcafe</sub>", and the url is <sub>http://kangcafe.com/cn/32d7c641-e67d-410b-a659-7d0e414b5c1d.html</sub>.
        </p>
        <p class="content__text-p--desc">
            <em>这里的大多数文章都写于很多年以前，十年历程，多于怀旧（@2006-2016）</em>
            <br>Copyright (C) 2016 KangCafe.com, All Rights Reserved
            <br>Made in China.
            <span class="text__span--link">
            ✎
            <a href="../index.html">Home</a> –
            <a href="./mood.html">Mood</a> –
            <a href="./source.html">Source</a> –
            <a href="./note.html">Note</a>.
          </span>
        </p>
    </section>
</footer>
<script type="text/javascript">
    ! function($) {
        $(window).scroll(function() {
            $(this).scrollTop() > 100 ? $("#back-to-top").fadeIn() : $("#back-to-top").fadeOut()
        }), $("#back-to-top").on("click", function(b) {
            return b.preventDefault(), $("html, body").animate({
                scrollTop: 0
            }, 100), !1
        });
    }(jQuery);
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?95e6652d7f50f8def7540e687f338f60";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>
<script type="text/javascript">
    (function() {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
</body>

</html>

