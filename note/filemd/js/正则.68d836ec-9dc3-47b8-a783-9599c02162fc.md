# 正则
<!-- toc -->
## 内置函数
### exec

exec 返回值属性为对象。

```js
var reg = /k/,
	str = 'kahn1990';
console.log(typeof reg.exec(str));
==> 'object'
```

其中共包含大约 (n+1) 个属性：index、input、数组。第三个属性为数组中的元素，匹配到一个则为 0，匹配到 n 个则为 (n-1)。

```js
var reg = /k/,
	str = 'kahn1990';
for( var key in reg.exec(str)){
	console.log('reg.exec(str)属性：'+key+'，其值为'+reg.exec(str)[key]+'；')
}
==> reg.exec(str)属性：index，其值为0；
==> reg.exec(str)属性：input，其值为kahn1990；
==> reg.exec(str)属性：0，其值为k；
==> undefined
```

在 exec 中设置 g 修饰符会更新正则表达式的 lastIndex 属性，表示本次匹配之后，下次匹配的索引从 lastIndex 开始。

```js
var reg = /k/,
	str = 'kahn1990';
console.log(reg.exec(str).index);
console.log(reg.exec(str).index);
==> 0
==> 0
var reg = /k/g,
	str = 'kahn1990';
console.log(reg.exec(str).index);
console.log(reg.exec(str).index);
==> 0
==> 1
```

### match

类似 exec，并同样具有 index 和 input 属性。

```js
var reg = /k/,
	str = 'kahn1990';
console.log(typeof str.match(reg));
==> 'object'
```

match 方法中 g 修饰符作用在完成匹配之后会继续匹配所有字符串直至结束，并且失去 index 和 input 属性。

### replace

replace 用于替换匹配到的字符串。

```js
var reg = /k/,
	str = 'kahn1990';
console.log(str.replace(reg, 'j');
==> 'jahn1990'
```

replace 方法中设置 g 修饰符之后会替换所有匹配的字符串。

```js
var reg = /9/,
	str = 'kahn1990';
console.log(str.replace(reg, '88');
==> 'kahn1880'
```

replace 函数中使用 $ 引用子正则表达式匹配内容。

```js
var reg = /（\w+)-(\w+)/,
	str = 'kahn1990-kangjian';
console.log(str.replace(reg, '$2-$2');
==> 'kangjian-kangjian'
```

在 replace 函数中 $ 符号有特殊含义，如果需要特意替换为 $ 符号需要使用 $$ 进行匹配。

### search

search 返回正则表达式第一次匹配的位置。

```js
var reg = /1/,
	str = 'kahn1990';
console.log(str.search(reg);
==> 4
```

### split

split 返回正则表达式第一次匹配的位置。

```js
var reg = /\W/,
	str = 'kahn1990-kangjian';
console.log(str.split(reg));
==> ["kahn1990", "kangjian"]
```

### test

test 检查 str 是否匹配成功，返回值为布尔类型。

```js
var reg = /k/,
	str = 'kahn1990';
console.log(typeof reg.test(str));
==> true
```

## 正则表达式对象

- regexp = new RegExp(patern[, flag])

生成正则表达式对象。正则表达式对象用在字符串的匹配上。下面的例子里，使用 match() 检查字符串 str 里有没有 "DEF" 。

```js
var str = "ABCDEFG",
	reg = new RegExp("DEF", "i");
if (str.match(reg)) {
    console.log("找到了DEF");
}
==> '找到了DEF'
```

为了符合面向对象中“数据类型都可以生成对象”的思想，JavaScript准备了new RegExp()，不过基本没什么人用。一般像下面这样写。

```js
var str = "ABCDEF";
if (str.match(/DEF/i)) {
    console.log("找到了DEF");
}
==> '找到了DEF'
```

如果只是要判断“是否含有DEF”的话，用 index() 更加简单。不过如果想搜索“12:34:56”这样的时间单位，用正则表达式就方便得多。

```js
var str = "12:34:56";
if (str.match(/^[0-9][0-9]:[0-9][0-9]:[0-9][0-9]$/)) {
    console.log("匹配");
}
==> '匹配'
```

RegExp() 的 flag 部分可以指定 "i"、"g"、"m" 。也可以像 "ig" 这样一起指定。详细内容请看下一节。

- regexp.ignoreCase
- regexp.global
- regexp.source

ignoreCase 返回有没有指定 i选项 的布尔值（就是上面match括号里 /.../ 的后面有没有加 i）。global 返回有没有指定 g选项 的布尔值。source 则返回正则表达式部分的字符串（就是上面match括号里 /.../ 的内容）。

```js
re = new RegExp("DEF", "ig");
document.write(re.ignoreCase + "<br>");   // → true
document.write(re.global + "<br>");       // → true
document.write(re.source + "<br>");       // → DEF
```

- RegExp.$

RegExp.$ 的形式与意义如下。

| 形式 | 意义 |
|--------|--------|
|RegExp.$n|第 n 个括号里的字符串。详细内容见后文。|
|RegExp.$&|等同于 RegExp.lastMatch 。|
|RegExp.$\`|等同于 RegExp.leftContext 。|
|RegExp.$"|等同于 RegExp.rightContext 。|
|RegExp.$+|等同于 RegExp.lastParen 。|
|RegExp.$_|等同于 RegExp.input 。|
|RegExp.$*|等同于 RegExp.multiline 。|


### 正则表达式语法

正则表达式可以用下面的形式来进行匹配。

| 正则表达式 | 意义 |
|--------|--------|
|A|字符A|
|ABC|字符串ABC|
|[ABC]|A、B、C其中一个字符|
|[A-C]|从A到C的其中一个字符|
|[^ABC]|不是A、B、C的任意一个字符|
|.|任意一个字符|
|A|匹配前面的子表达式零次或多次。例如，"AP" 能匹配 "A" 以及 "APP"。 * 等价于{0,}。|
|A+|匹配前面的子表达式一次或多次。例如，"AP+" 能匹配 "AP" 以及 "APP"，但不能匹配 "A"。+ 等价于 {1,}。|
|A?|匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。|
|^A|以A开始的字符串|
|A$|以A结束的字符串|
|ABC&#124;DEF&#124;GHI|ABC或DEF或GHI|
|A{2}|2个A（AA）|
|A{2,}|2个以上A（AA、AAA、AAAA、...）|
|A{2,3}|2个～3个A（AA、AAA）|
|[\b]|退格|


反斜杠（\）后面的字符有特殊的意思。

| 形式 | 意义 |
|--------|--------|
|\b|空格等单词的分隔|
|\B|\b以外的字符|
|\cA|Ctrl-A|
|\d|任意数值（等同于 [0-9]）|
|\D|数值以外的字符（等同于[^0-9]）|
|\f|换页符|
|\n|换行符|
|\r|回车|
|\s|一个字符的分隔符（[ \f\n\r\t\v]）|
|\S|\s以外的一个字符|
|\t|制表符（TAB符）|
|\v|垂直制表符|
|\w|英文字母和数字（等同于 [A-Za-z0-9_]）|
|\W|\w以外的字符|
|\2|匹配第2个 (...) 的字符串|
|\o033|8进制数033的字符|
|\x1b|16进制数1b的字符|
|\其他|其他字符自身|

RegExp() 的第2个参数，或是写在 /.../ 后面的 i、g、m 的意义如下。

| 选项 | 意义 |
|--------|--------|
|i|不区分大小写|
|g|全文匹配（不光匹配第一个）|
|m|搜索复数行|

### 匹配

- regexp.exec([str])
- str.match(regexp)

执行匹配，返回匹配部分的字符串（指定 g 选项时返回数组）。exec() 里省略 str 的时候，会用在 RegExp.input 里指定的字符串进行匹配。

```js
re = new RegExp("[0-9]+");
document.write(re.exec("abc123") + "<br>");         // → 123
document.write("abc123".match(re) + "<br>");        // → 123
document.write("abc123".match(/[0-9]+/) + "<br>");  // → 123
```

- regexp.compile(patern[, flag])

把正则表达式预先编译为内部表达式以提高匹配的速度。（个人感觉没什么区别）

```js
re = new RegExp("");
re.compile("[0-9]+");
for (i = 0; i < 1000; i++) {
    if (str.match(re)) {
        :
    }
}
```

- RegExp.input

把匹配字符串传递给 exec() 。等同与 $_ 。

```js
re = new RegExp("[0-9]+");
RegExp.input = "abc123";
document.write(RegExp.exec() + "<br>");
RegExp.input = "xyz456";
document.write(RegExp.exec() + "<br>");
```

- RegExp.multiline

设定为 true 的话效果跟 m 选项一样执行复数行匹配。等同与 $* 。

```js
RegExp.multiline = false;
document.write("123\n456\n789".match(/^456/) + "<br>");
RegExp.multiline = true;
document.write("123\n456\n789".match(/^456/) + "<br>");
```

### 匹配结果

- RegExp.$n

返回之前执行的正则表达式匹配中的第 n 个 (...) 对应的字符串。

```js
"12:34:56".match(/(\d+):(\d+):(\d+)/);
document.write(RegExp.$1 + "<br>");   // → 12
document.write(RegExp.$2 + "<br>");   // → 34
document.write(RegExp.$3 + "<br>");   // → 56
```

- RegExp.index
- RegExp.lastIndex

index 是匹配到的字符串的起始位置，lastIndex 是匹配到的字符串的后面一个字符的位置。开始的字符的位置为 0 。

```js
re = new RegExp("123");
"abc123def".match(re);
document.write(RegExp.index);     // → 3
document.write(RegExp.lastIndex); // → 6
```

- RegExp.lastMatch
- RegExp.leftContext
- RegExp.rightContext
- RegExp.lastParen

返回之前执行的字符串匹配中的，最后匹配到的字符串（lastMatch）、匹配到的字符串的左边的字符串（leftContext）、匹配到的字符串的右边的字符串（rightContext），以及最后的 (...) 所对应的字符串（lastParen）。它们分别等同于 $&、$`、$'、$+ 。

```js
"abc123def".match(/(123)/);
document.write(RegExp.lastMatch + "<br>");    // → 123
document.write(RegExp.leftContext + "<br>");  // → abc
document.write(RegExp.rightContext + "<br>"); // → def
document.write(RegExp.lastParen + "<br>");    // → 123
```




## 常用正则

统一空格个数

```js
var reg = /\s+/g,
	str = 'k  a h  n   1  9  9    0';
console.log(str.replace(reg, ' '));
==> 'k a h n 1 9 9 0'
```

判断字符串是否由数字组成

```js
var reg = /^\d*$/,
	str = '13100888202';
console.log(reg.test(str));
==> true
```

电话号码正则

```js
var reg = /^\d{3,4}-\d{7,8}(-d{3,4})?$/,
	str = '0455-7711221';
console.log(reg.test(str));
==> true
```

手机号码正则

```js
var reg = /^0*(13|15)\d{9}$/,
	str = '13100888202';
console.log(reg.test(str));
==> true
```

删除字符串两侧的空白字符

```js
var reg = /^\s+|\s+$/g,
	str = ' 131 ';
console.log(str.replace(reg,'').length);
==> 3
```

删除字符串左侧的空白字符

```js
var reg = /^\s+$/g,
	str = ' 131 ';
console.log(str.replace(reg,'').length);
==> 4
```

删除字符串右侧的空白字符

```js
var reg = /\s+$/g,
	str = ' 131 ';
console.log(str.replace(reg,'').length);
==> 4
```

限制文本框只能输入数字和小数点

```js
/^\d*\.?\d{0,2}$/
```

只能由中文、英文、数字、下划线、4-16个字符

```js
/^[\u4E00-\u9FA5\uf900-\ufa2d\w]{4,16}$/
```

包含点、字母、空格、逗号、数字，但开头换个结尾不能是字母之外的字符。

```js
/^[a-zA-Z][\.a-zA-Z\s,0-9]*?[a-zA-Z]+$/
```

开头数字诺干，小数点后数字一到两位

```js
/^(\d*\.\d{0,2}|\d+).*$/
```

身份证号码正则

```js
/^(\d{14}|\d{17})(\d|[xX])$/
```

匹配文本并指定行数

```js
/\S+?\s*?[\n\r]\S*?\S+?/i
```

单词首字母大写

```js
/\b(\w)|\s(\w)/g
```

验证日期格式

```js
/^\d{4}(-|\/)\d{1,2}(-|\/)\d{1,2}$/
```

去掉文件的后缀名

```js
/\.\w+$/
```

验证邮箱

```js
/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-)+/
```

匹配源码中的链接

```js
/<a\s(\s*\w*?\s*=\s*".+?")*(\s*href\s*=\s*".+?")(\s*\w*?\s*=\s*".+?")*\s*>[\s\S]*?<\/a>/g
```

匹配链接的文字

```js
/<a\s(?:\s*\w*?\s*=\s*".+?")*(?:\s*href\s*=\s*".+?")(?:\s*\w*?\s*=\s*".+?")*\s*>[\s\S]*?<\/a>/g
```

正则判断标签是否闭合

```js
/<([a-z]+)(\s*\w*?\s*=\s*".+?")*(\s*?>[\s\S]*?(<\/\1>)+|\s*\/>)/i
```

判断是否为数字和字母组合

```js
/^([a-z]+(?=[0-9])|[0-9]+(?=[a-z]))[a-z0-9]+$/ig
```

匹配url

```js
/http:\/\/[\w-]*(\.[\w-]*)+/ig
```
